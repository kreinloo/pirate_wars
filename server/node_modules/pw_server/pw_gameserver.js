/*

	pw_gameserver.js

*/

var util = require("util");

GameServer = (function (server) {

	"use strict";

	this.server = server;
	this.activeGames = {};

	this.createGame = function (player1, player2) {
		var gid = this.generateGameId();
		var game = new Game (gid, this, player1, player2);
		this.activeGames[gid] = (game);
		game.init();

		var data = {
			gid : gid,
			player1 : player1.getName(),
			player2 : player2.getName()
		};
		player1.setGameStatus(GAME.STATUS.PLAYING);
		player2.setGameStatus(GAME.STATUS.PLAYING);
		if (DEBUG.GAMESERVER)
			util.log("GAME CREATED: gid: " + data.gid + " " + data.player1 +
				" vs " + data.player2);
		return data;
	};

	this.endGame = function (gid) {
		if (DEBUG.GAMESERVER)
			util.log("GAMESERVER: ENDED GAME : " + gid);
		this.server.emitEndedGame({
			gid : gid
		});
		var p1Id = this.activeGames[gid].pids[0];
		var p2Id = this.activeGames[gid].pids[1];
		var client1, client2;
		client1 = this.server.getClientById(p1Id);
		client2 = this.server.getClientById(p2Id);

		if (client1 != null)
			client1.setGameStatus(GAME.STATUS.IDLE);
		if (client2 != null)
			client2.setGameStatus(GAME.STATUS.IDLE);
		delete this.activeGames[gid];
	};

	this.generateGameId = function () {
		var id = new String(Math.random()).slice(2);
		if (this.activeGames[id] === undefined) {
			return id;
		} else {
			return this.generateGameId();
		}
	};

	this.handleGameInfo = function (data) {
		if (data.gid === undefined ||
				this.activeGames[data.gid] === undefined) {
			return;
		}
		// private chat is handled directly by gameserver
		// no need to invoke Game instance
		if (data.action === GAME.ACTION.PRIVATE_CHAT) {
			var gid = data.gid;
			var pid1 = this.activeGames[gid].pids[0];
			var pid2 = this.activeGames[gid].pids[1];
			server.emitGameInfo(pid1, data);
			server.emitGameInfo(pid2, data);
		} else {
			this.activeGames[data.gid].call(data);
		}
	};

	this.emitGameInfo = function (data) {
		if (this.activeGames[data.gid] === undefined) {
			return;
		}
		if (DEBUG.GAMESERVER)
			util.log("GAMESERVER EMIT INFO: " + JSON.stringify(data));
		server.emitGameInfo(data.pid, data);
	};

	this.getActiveGames = function () {
		var list = [];
		var game, gameRecord;
		for (var i in this.activeGames) {
			game = this.activeGames[i];
			gameRecord = {
				gid : game.gid,
				player1 : game.players[game.pids[0]].getName(),
				player2 : game.players[game.pids[1]].getName()
			}
			list.push(gameRecord);
		}
		return list;
	};

	this.playerDisconnected = function (pid) {
		var game;
		for (var key in this.activeGames) {
			game = this.activeGames[key];
			if (game.pids[0] === pid || game.pids[1] === pid) {
				if (DEBUG.GAMESERVER)
					util.log("GAMESERVER: Player disconnected: " + pid);
				game.playerDisconnected(pid);
			}
		}
	};

});

var Game = (function (gid, gs, p1, p2) {

	"use strict";

	this.gid = gid;
	this.gameServer = gs;
	this.players = {};
	this.players[p1.getID()] = new Player(p1.getID(), p1.getName());
	this.players[p2.getID()] = new Player(p2.getID(), p2.getName());
	this.name = "PID: " + this.gid + " " + p1.getName() + " vs " + p2.getName();

	this.phase = GAME.PHASE.ALIGNMENT;
	this.pids = [p1.getID(), p2.getID()];
	this.activePlayer = null;

	/*
		GameServer will invoke the specific game who will handle
		all the game logic.
	*/
	this.call = function (data) {

		var params = data.params;

		switch(data.action) {

			case GAME.ACTION.ADD_HORIZONTAL_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					addHorizontalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.ADD_VERTICAL_SHIP:
				this.players[data.pid].getGameField().
					addVerticalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.DELETE_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					deleteShip(params.row, params.col);
				break;

			case GAME.ACTION.RESET_FIELD:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (this.players[data.pid].getReady()) {
					this.sendServerMessage(data.pid,
						"You already confirmed your ship placement.");
				} else {
					this.players[data.pid].getGameField().
						resetField();
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.RESET_FIELD,
						params : {}
					});
					this.sendServerMessage(data.pid,
						"Your ships are reset!");
				}
				break;

			case GAME.ACTION.CONFIRM_ALIGNMENT:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (!this.players[data.pid].getReady()) {
					// TODO: final validation by server!!!
					this.players[data.pid].setReady(true);
					this.sendServerMessage(data.pid,
						"Your ships are placed! Please wait for your opponent.");
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.CONFIRM_ALIGNMENT,
						params : {}
					});
					var opponentID = data.pid === this.pids[0] ?
						this.pids[1] : this.pids[0];
					this.sendServerMessage(opponentID,
						this.players[opponentID].getName() + " has placed his/her ships.");

				} else {
					this.sendServerMessage(data.pid,
						"You ships are already positioned!");
				}

				if (this.areBothPlayersReady()) {
					this.loadBattlePhase();
					// for debugging client side
					this.endGame();
				}
				break;

			case GAME.ACTION.FIREAT:
				if (this.phase !== GAME.PHASE.BATTLE) return;
				if (data.activePlayer !== data.pid) {
					this.sendServerMessage(data.pid,
						"It is not your turn, please wait ...");
					return;
				}

				var opponent = this.pids[0] === data.pid ? this.pids[1]: this.pids[0];
				var result = this.players[opponent].getGameTable().
					fireAt(params.row, params.col);
				break;

		}

	};

	this.areBothPlayersReady = function () {
		return this.players[this.pids[0]].getReady() &&
			this.players[this.pids[1]].getReady();
	};

	this.loadBattlePhase = function () {
		this.phase = GAME.PHASE.BATTLE;
		util.log(this.name + "\nGAME STARTED!");
		this.activePlayer = Math.random() > 0.5 ? this.pids[0] : this.pids[1];

		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendServerMessage(this.pids[0], "Battle has started! Good luck!");
		this.sendServerMessage(this.pids[1], "Battle has started! Good luck!");
	};

	this.flipActivePlayer = function () {
		this.activePlayer = this.activePlayer === this.pids[0] ?
			this.pids[1] : this.pids[0];
	};

	this.sendEventResult = function (data) {
		data.gid = this.gid;
		if (DEBUG.GAME)
			util.log("GAME EMIT INFO: " + JSON.stringify(data));
		this.gameServer.emitGameInfo(data);
	};

	this.sendServerMessage = function (pid, message) {
		this.sendEventResult({
			pid : pid,
			action : GAME.ACTION.PRIVATE_CHAT,
			params : { author : "Server", msg : message }
		});
	};

	this.init = function () {
		// notifying two players that their game has started
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.START,
			opponentName : this.players[this.pids[1]].getName()
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.START,
			opponentName : this.players[this.pids[0]].getName()
		});
		// telling players to reset their game fields
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.RESET_FIELD,
			params : {}
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.RESET_FIELD,
			params : {}
		});
	};

	this.endGame = function (data) {
		util.log(JSON.stringify(data));
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.GAME_OVER,
			msg : data.msg
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.GAME_OVER,
			msg : data.msg
		});
		if (DEBUG.GAME)
			util.log("GAME: GAME ENDED : " + this.gid);
		this.gameServer.endGame(this.gid);
	};

	this.playerDisconnected = function (pid) {
		var data = { msg : "Your opponent has disconnected!" };
		util.log(JSON.stringify(data));
		this.endGame(data);
	};

});

/*
	Class: Player()
	Represents player, holds necessary information and references
	about her: like history of moves, reference to field object,
	whether player is ready for battle (in alignment phase).
*/
var Player = (function (_id_, _name_) {

	"use strict";

	var pid = _id_;
	var name = _name_;
	var gameField;
	var movesHistory;
	var ready;

	gameField = new Field();
	movesHistory = [];
	ready = false;
	return {
		getMovesHistory: function () {
			return movesHistory;
		},

		isMoveUnique: function (row, col) {
			var index = $.inArray(row + 'x' + col, movesHistory);
			return (index === -1 ? true : false);
		},

		pushMove: function (row, col) {
			movesHistory.push(row + 'x' + col);
		},

		getGameField: function () {
			return gameField;
		},

		setReady: function (isReady) {
			ready = isReady;
		},

		getReady: function () {
			return ready;
		},

		getID : function () {
			return pid;
		},

		getName : function () {
			return name;
		}
	};
});

/*
	Class: Field()
	Represents the field of game and provides manipulation with it.
	Basically has 10x10 matrix that holds information about each cell.
	Also knows how many ships are left in the field (getShipsLeft() method).
*/
var Field = (function() {
	/*
		0 - water (not shot)
		1 - water (shot)
		2 - ship  (not shot)
		3 - ship (shot)
	*/

	"use strict";

	var matrix;
	var shipsLeft;

	function initializeMatrix() {
		matrix = new Array(10);
		for (var i = 0; i < 10; i++) {
			matrix[i] = new Array(10);
			for (var j = 0; j < 10; j++)
			matrix[i][j] = 0;
		}
	}

	function addShip(row, col, row_len, col_len) {
		if ((row < 0) || (col < 0)) return;
		if ((row >= 10) || (col >= 10)) return;

		if ((row_len == 0) && (col_len == 0)) return;

		matrix[row][col] = 2;
		addShip(
			row_len != 0 ? row + 1 : row,
			col_len != 0 ? col + 1 : col,
			row_len != 0 ? row_len - 1 : 0,
			col_len != 0 ? col_len - 1 : 0);
	}

	initializeMatrix();
	shipsLeft = 0;

	return {

		resetField: function () {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++)
				matrix[i][j] = 0;
			}
			shipsLeft = 0;
		},
		getMatrix: function () {
			return matrix;
		},

		printMatrix: function () {
			for (var i = 0; i < 10; i++)
			util.debug(matrix[i]);
		},

		getShipsLeft: function () {
			return shipsLeft;
		},

		fireAt: function (row, col) {
			function countWholeParts(row, col, move_row, move_col) {
				if ((typeof move_row == 'undefined') &&
						(typeof move_col == 'undefined')) {
					var count;
					count = countWholeParts(row + 1, col, 1, 0);
					count += countWholeParts(row - 1, col, -1, 0);
					count += countWholeParts(row, col + 1, 0, 1);
					count += countWholeParts(row, col - 1, 0, -1);
					return count;
				}

				if ((row < 0) || (col < 0)) return 0;
				if ((row >= 10) || (col >= 10)) return 0;
				if (matrix[row][col] < 2) return 0;

				return (matrix[row][col] == 2 ? 1 : 0) +
					countWholeParts(row + move_row, col + move_col, move_row, move_col);
			}

			if (shipsLeft <= 0) return HIT.GAME_OVER;

			switch (matrix[row][col]) {
				case 0:
					matrix[row][col] = 1;
					return HIT.WATER;
				case 1:
					throw ERROR.ILLEGAL_MOVE;
				case 2:
					matrix[row][col] = 3;
					if (countWholeParts(row, col) == 0) {
						shipsLeft--;
						if (shipsLeft <= 0) return HIT.GAME_OVER;
						return HIT.WHOLE_SHIP;
					}
					return HIT.SHIP;
				case 3:
					throw ERROR.ILLEGAL_MOVE;
			}

		},

		addVerticalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship vertically : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, length, 0);
			shipsLeft++;
		},

		addHorizontalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship horizontally : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, 0, length);
			shipsLeft++;
		},

		deleteShip: function (row, col) {
			if (DEBUG.GAME)
				util.debug("Game: Deleted ship : " + row + " " + col);

			function recursiveDelete(row, col, move_row, move_col) {
				if ((row < 0) || (col < 0)) return;
				if ((row >= 10) || (col >= 10)) return;
				if (matrix[row][col] < 2) return;

				matrix[row][col] = 0;
				recursiveDelete(row + move_row, col + move_col, move_row, move_col);
			}

			if (matrix[row][col] < 2) return;

			matrix[row][col] = 0;
			recursiveDelete(row + 1, col, 1, 0);
			recursiveDelete(row - 1, col, -1, 0);
			recursiveDelete(row, col + 1, 0, 1);
			recursiveDelete(row, col - 1, 0, -1);
			shipsLeft--;
		}
	}
});

module.exports = GameServer;
