/*

	pw_gameserver.js

*/

var util = require("util");

GameServer = (function (server) {

	this.server = server;

	this.activeGames = {};

	this.createGame = function (player1, player2) {

		var gid = this.generateGameId();
		var game = new Game (gid, this, player1, player2);
		this.activeGames[gid] = (game);
		if (DEBUG.GAMESERVER)
			util.log("GAME CREATED: gid: " + gid + " " +
				player1.getName() + " vs " + player2.getName());
		return gid;

	};

	this.generateGameId = function () {

		var id = new String(Math.random()).slice(2);
		if (this.activeGames[id] === undefined) {
			return id;
		} else {
			return this.generateGameId();
		}

	};

	this.handleGameInfo = function (data) {

		if (data.gid === undefined ||
				this.activeGames[data.gid] === undefined) {
			return;
		}

		if (data.action === GAME.ACTION.PRIVATE_CHAT) {
			var gid = data.gid;
			var pid1 = this.activeGames[gid].pids[0];
			var pid2 = this.activeGames[gid].pids[1];
			server.emitGameInfo(pid1, data);
			server.emitGameInfo(pid2, data);
		}

		this.activeGames[data.gid].call(data);

	};

	this.emitGameInfo = function (data) {

		if (this.activeGames[data.gid] === undefined) {
			return;
		}
		server.emitGameInfo(data.pid, data);

	}

});

var Game = (function (gid, gameServer, player1, player2) {

	this.gid = gid;
	this.gameServer = gameServer;
	this.players = {};
	this.players[player1.getID()] = new Player(player1.getID(), player1.getName());
	this.players[player2.getID()] = new Player(player2.getID(), player2.getName());
	this.name = "PID: " + this.gid + " " + player1.getName() + " vs " + player2.getName();

	this.phase = GAME.PHASE.ALIGNMENT;
	this.pids = [player1.getID(), player2.getID()];
	this.activePlayer = null;

	this.call = function (data) {

		var params = data.params;

		switch(data.action) {

			case GAME.ACTION.ADD_HORIZONTAL_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					addHorizontalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.ADD_VERTICAL_SHIP:
				this.players[data.pid].getGameField().
					addVerticalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.DELETE_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					deleteShip(params.row, params.col);
				break;

			case GAME.ACTION.RESET_FIELD:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (this.players[data.pid].getReady()) {
					this.sendServerMessage(data.pid,
						"You already confirmed your ship placement.");
				} else {
					this.players[data.pid].getGameField().
						resetField();
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.RESET_FIELD,
						params : {}
					});
					this.sendServerMessage(data.pid,
						"Your ships are reset!");
				}
				break;

			case GAME.ACTION.CONFIRM_ALIGNMENT:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (!this.players[data.pid].getReady()) {
					// TODO: final validation by server!!!
					this.players[data.pid].setReady(true);
					this.sendServerMessage(data.pid,
						"Your ships are placed! Please wait for your opponent.");
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.CONFIRM_ALIGNMENT,
						params : {}
					});
					var opponentID = data.pid === this.pids[0] ? this.pids[1] : this.pids[0];
					this.sendServerMessage(opponentID, this.players[opponentID].getName() +
						" has placed his/her ships.")

				} else {
					this.sendServerMessage(data.pid,
						"You ships are already positioned!");
				}

				if (this.areBothPlayersReady()) {
					this.loadBattlePhase();
				}
				break;

			case GAME.ACTION.FIREAT:
				if (this.phase !== GAME.PHASE.BATTLE) return;
				if (data.activePlayer !== data.pid) {
					this.sendServerMessage(data.pid,
						"It is not your turn, please wait ...");
					return;
				}

				var opponent = this.pids[0] === data.pid ? this.pids[1]: this.pids[0];
				var result = this.players[opponent].getGameTable().
					fireAt(params.row, params.col);
				break;

		}

	};

	this.areBothPlayersReady = function () {
		return this.players[this.pids[0]].getReady() &&
			this.players[this.pids[1]].getReady();
	};

	this.loadBattlePhase = function () {
		this.phase = GAME.PHASE.BATTLE;
		util.log(this.name + "\nGAME STARTED!");
		this.activePlayer = Math.random() > 0.5 ? this.pids[0] : this.pids[1];

		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendServerMessage(this.pids[0],
			"Battle has started! Good luck!");
		this.sendServerMessage(this.pids[1],
			"Battle has started! Good luck!");

	};

	this.flipActivePlayer = function () {
		this.activePlayer = this.activePlayer === this.pids[0] ? this.pids[1] : this.pids[0];
	};

	this.sendEventResult = function (data) {
		this.gameServer.emitGameInfo({
			gid : this.gid,
			pid : data.pid,
			action : data.action,
			params : data.params
		});
	};

	this.sendServerMessage = function (pid, message) {
		this.sendEventResult({
			pid : pid,
			action : GAME.ACTION.PRIVATE_CHAT,
			params : { author : "Server", msg : message }
		});
	}

});

/*
	Class: Player()
	Represents player, holds necessary information and references
	about her: like history of moves, reference to field object,
	whether player is ready for battle (in alignment phase).
*/
var Player = (function (_id_, _name_) {

	var pid = _id_;
	var name = _name_;
	var gameField;
	var movesHistory;
	var ready;

	gameField = new Field();
	movesHistory = [];
	ready = false;
	return {
		getMovesHistory: function () {
			return movesHistory;
		},

		isMoveUnique: function (row, col) {
			var index = $.inArray(row + 'x' + col, movesHistory);
			return (index == -1 ? true : false);
		},

		pushMove: function (row, col) {
			movesHistory.push(row + 'x' + col);
		},

		getGameField: function () {
			return gameField;
		},

		setReady: function (isReady) {
			ready = isReady;
		},

		getReady: function () {
			return ready;
		},

		getID : function () {
			return pid;
		},

		getName : function () {
			return name;
		}
	}
});

/*
	Class: Field()
	Represents the field of game and provides manipulation with it.
	Basically has 10x10 matrix that holds information about each cell.
	Also knows how many ships are left in the field (getShipsLeft() method).
*/
var Field = (function() {
	/*
		0 - water (not shot)
		1 - water (shot)
		2 - ship  (not shot)
		3 - ship (shot)
	*/

	var matrix;
	var shipsLeft;

	function initializeMatrix() {
		matrix = new Array(10);
		for (var i = 0; i < 10; i++) {
			matrix[i] = new Array(10);
			for (var j = 0; j < 10; j++)
			matrix[i][j] = 0;
		}
	}

	function addShip(row, col, row_len, col_len) {
		if ((row < 0) || (col < 0)) return;
		if ((row >= 10) || (col >= 10)) return;

		if ((row_len == 0) && (col_len == 0)) return;

		matrix[row][col] = 2;
		addShip(
			row_len != 0 ? row + 1 : row,
			col_len != 0 ? col + 1 : col,
			row_len != 0 ? row_len - 1 : 0,
			col_len != 0 ? col_len - 1 : 0);
	}

	initializeMatrix();
	shipsLeft = 0;

	return {

		resetField: function () {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++)
				matrix[i][j] = 0;
			}
			shipsLeft = 0;
		},
		getMatrix: function () {
			return matrix;
		},

		printMatrix: function () {
			for (var i = 0; i < 10; i++)
			util.debug(matrix[i]);
		},

		getShipsLeft: function () {
			return shipsLeft;
		},

		fireAt: function (row, col) {
			function countWholeParts(row, col, move_row, move_col) {
				if ((typeof move_row == 'undefined') && (typeof move_col == 'undefined')) {
					var count;
					count = countWholeParts(row + 1, col, 1, 0);
					count += countWholeParts(row - 1, col, -1, 0);
					count += countWholeParts(row, col + 1, 0, 1);
					count += countWholeParts(row, col - 1, 0, -1);
					return count;
				}

				if ((row < 0) || (col < 0)) return 0;
				if ((row >= 10) || (col >= 10)) return 0;
				if (matrix[row][col] < 2) return 0;

				return (matrix[row][col] == 2 ? 1 : 0) + countWholeParts(row + move_row,
					col + move_col, move_row, move_col);
			}

			if (shipsLeft <= 0) return HIT.GAME_OVER;

			switch (matrix[row][col]) {
				case 0:
					matrix[row][col] = 1;
					return HIT.WATER;
				case 1:
					throw ERROR.ILLEGAL_MOVE;
				case 2:
					matrix[row][col] = 3;
					if (countWholeParts(row, col) == 0) {
						shipsLeft--;
						if (shipsLeft <= 0) return HIT.GAME_OVER;
						return HIT.WHOLE_SHIP;
					}
					return HIT.SHIP;
				case 3:
					throw ERROR.ILLEGAL_MOVE;
			}

		},

		addVerticalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship vertically : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, length, 0);
			shipsLeft++;
		},

		addHorizontalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship horizontally : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, 0, length);
			shipsLeft++;
		},

		deleteShip: function (row, col) {
			if (DEBUG.GAME)
				util.debug("Game: Deleted ship : " + row + " " + col);

			function recursiveDelete(row, col, move_row, move_col) {
				if ((row < 0) || (col < 0)) return;
				if ((row >= 10) || (col >= 10)) return;
				if (matrix[row][col] < 2) return;

				matrix[row][col] = 0;
				recursiveDelete(row + move_row, col + move_col, move_row, move_col);
			}

			if (matrix[row][col] < 2) return;

			matrix[row][col] = 0;
			recursiveDelete(row + 1, col, 1, 0);
			recursiveDelete(row - 1, col, -1, 0);
			recursiveDelete(row, col + 1, 0, 1);
			recursiveDelete(row, col - 1, 0, -1);
			shipsLeft--;
		}
	}
});

module.exports = GameServer;
