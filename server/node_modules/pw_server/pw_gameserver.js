/*

	pw_gameserver.js

*/

util = require("util");

GameServer = (function (server) {

	this.server = server;

	this.activeGames = {};

	this.createGame = function (player1, player2) {

		var gid = this.generateGameId();
		var game = new Game (gid, this, player1, player2);
		this.activeGames[gid] = (game);
		return gid;
		util.log("GAME CREATED: gid: " + gid + " " +
			player1.getName() + " vs " + player2.getName());

	};

	this.generateGameId = function () {

		var id = new String(Math.random()).slice(2);
		if (this.activeGames[id] === undefined) {
			return id;
		} else {
			return this.generateGameId();
		}

	};

	this.handleGameInfo = function (data) {

		if (data.gid === undefined || this.activeGames[data.gid] === undefined) {
			return;
		}

		if (data.action === GAME.ACTION.PRIVATE_CHAT) {
			var gid = data.gid;
			var pid1 = this.activeGames[gid].pids[0];
			var pid2 = this.activeGames[gid].pids[1];
			server.emitGameInfo(pid1, data);
			server.emitGameInfo(pid2, data);
		}

		this.activeGames[data.gid].call(data);

	};

	this.emitGameInfo = function (data) {

		if (this.activeGames[gid] === undefined) {
			return;
		}

		server.emitGameInfo(data.pid, data);

	}

});

var Game = (function (gid, gameServer, player1, player2) {

	this.gid = gid;
	this.gameServer = gameServer;
	this.players = {};
	this.players[player1.getID()] = new Player(player1.getID());
	this.players[player2.getID()] = new Player(player2.getID());
	this.name = "PID: " + this.gid + " " + player1.getName() + " vs " + player2.getName();

	this.phase = GAME.PHASE.ALIGNMENT;
	this.pids = [player1.getID(), player2.getID()];

	this.call = function (data) {

		var params = data.params;

		switch(data.action) {

			case GAME.ACTION.ADD_HORIZONTAL_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					addHorizontalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.ADD_VERTICAL_SHIP:
				this.players[data.pid].getGameField().
					addVerticalShip(params.row, params.col, params.len);
				break;

			case GAME.ACTION.DELETE_SHIP:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					deleteShip(params.row, params.col);
				break;

			case GAME.ACTION.RESET_FIELD:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;
				this.players[data.pid].getGameField().
					resetField();
				break;

			case GAME.ACTION.CONFIRM_ALIGNMENT:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				// TODO: final validation by server!!!
				this.players[data.pid].setReady(true);

				if (this.areBothPlayersReady()) {
					phase = GAME.PHASE.BATTLE;
					util.log(this.name + "\nGAME STARTED!");
				}
				break;

		}

	};

	this.areBothPlayersReady = function () {
		return this.players[this.pids[0]].getReady() &&
			this.players[this.pids[1]].getReady();
	};

});

/*
	Class: Player()
	Represents player, holds necessary information and references
	about her: like history of moves, reference to field object,
	whether player is ready for battle (in alignment phase).
*/
var Player = (function (id) {

	var pid = pid;
	var gameField;
	var movesHistory;
	var ready;

	gameField = new Field();
	movesHistory = [];
	ready = false;
	return {
		getMovesHistory: function () {
			return movesHistory;
		},

		isMoveUnique: function (row, col) {
			var index = $.inArray(row + 'x' + col, movesHistory);
			return (index == -1 ? true : false);
		},

		pushMove: function (row, col) {
			movesHistory.push(row + 'x' + col);
		},

		getGameField: function () {
			return gameField;
		},

		setReady: function (isReady) {
			ready = isReady;
		},

		getReady: function () {
			return ready;
		},

		getID : function () {
			return pid;
		}
	}
});

/*
	Class: Field()
	Represents the field of game and provides manipulation with it.
	Basically has 10x10 matrix that holds information about each cell.
	Also knows how many ships are left in the field (getShipsLeft() method).
*/
var Field = (function() {
	/*
		0 - water (not shot)
		1 - water (shot)
		2 - ship  (not shot)
		3 - ship (shot)
	*/

	var matrix;
	var shipsLeft;

	function initializeMatrix() {
		matrix = new Array(10);
		for (var i = 0; i < 10; i++) {
			matrix[i] = new Array(10);
			for (var j = 0; j < 10; j++)
			matrix[i][j] = 0;
		}
	}

	function addShip(row, col, row_len, col_len) {
		if ((row < 0) || (col < 0)) return;
		if ((row >= 10) || (col >= 10)) return;

		if ((row_len == 0) && (col_len == 0)) return;

		matrix[row][col] = 2;
		addShip(
			row_len != 0 ? row + 1 : row,
			col_len != 0 ? col + 1 : col,
			row_len != 0 ? row_len - 1 : 0,
			col_len != 0 ? col_len - 1 : 0);
	}

	initializeMatrix();
	shipsLeft = 0;

	return {

		resetField: function () {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++)
				matrix[i][j] = 0;
			}
			shipsLeft = 0;
		},
		getMatrix: function () {
			return matrix;
		},

		printMatrix: function () {
			for (var i = 0; i < 10; i++)
			console.log(matrix[i]);
		},

		getShipsLeft: function () {
			return shipsLeft;
		},

		fireAt: function (row, col) {
			function countWholeParts(row, col, move_row, move_col) {
				if ((typeof move_row == 'undefined') && (typeof move_col == 'undefined')) {
					var count;
					count = countWholeParts(row + 1, col, 1, 0);
					count += countWholeParts(row - 1, col, -1, 0);
					count += countWholeParts(row, col + 1, 0, 1);
					count += countWholeParts(row, col - 1, 0, -1);
					return count;
				}

				if ((row < 0) || (col < 0)) return 0;
				if ((row >= 10) || (col >= 10)) return 0;
				if (matrix[row][col] < 2) return 0;

				return (matrix[row][col] == 2 ? 1 : 0) + countWholeParts(row + move_row,
					col + move_col, move_row, move_col);
			}

			if (shipsLeft <= 0) return HIT.GAME_OVER;

			switch (matrix[row][col]) {
			case 0:
				matrix[row][col] = 1;
				return HIT.WATER;
			case 1:
				throw ERROR.ILLEGAL_MOVE;
			case 2:
				matrix[row][col] = 3;
				if (countWholeParts(row, col) == 0) {
					shipsLeft--;
					if (shipsLeft <= 0) return HIT.GAME_OVER;
					return HIT.WHOLE_SHIP;
				}
				return HIT.SHIP;
			case 3:
				throw ERROR.ILLEGAL_MOVE;
			}

		},

		addVerticalShip: function (row, col, length) {
			console.log("Server: Added ship vertically : row: " + row +
				" col: " + col + " Length: " + length);
			addShip(row, col, length, 0);
			shipsLeft++;
		},

		addHorizontalShip: function (row, col, length) {
			console.log("Server: Added ship horizontally : row: " + row +
				" col: " + col + " Length: " + length);
			addShip(row, col, 0, length);
			shipsLeft++;
		},

		deleteShip: function (row, col) {
			console.log("deleted ship : " + row + " " + col);

			function recursiveDelete(row, col, move_row, move_col) {
				if ((row < 0) || (col < 0)) return;
				if ((row >= 10) || (col >= 10)) return;
				if (matrix[row][col] < 2) return;

				matrix[row][col] = 0;
				recursiveDelete(row + move_row, col + move_col, move_row, move_col);
			}

			if (matrix[row][col] < 2) return;

			matrix[row][col] = 0;
			recursiveDelete(row + 1, col, 1, 0);
			recursiveDelete(row - 1, col, -1, 0);
			recursiveDelete(row, col + 1, 0, 1);
			recursiveDelete(row, col - 1, 0, -1);
			shipsLeft--;
		}
	}
});

module.exports = GameServer;
