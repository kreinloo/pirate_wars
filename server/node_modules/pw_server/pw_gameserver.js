/*

	pw_gameserver.js

	GameServer creates/ends games, handles private chat and
	acts as a middleman between Server and Game instances.

*/

var util = require("util");
var sanitizer = require("sanitizer");

GameServer = (function (server) {

	"use strict";

	this.server = server;
	this.activeGames = {};

	this.createGame = function (player1, player2) {
		var gid = this.generateGameId();
		var game = new Game (gid, this, player1, player2);
		this.activeGames[gid] = (game);
		game.init();

		var data = {
			gid : gid,
			player1 : player1.getName(),
			player2 : player2.getName()
		};
		player1.setGameStatus(GAME.STATUS.PLAYING);
		player2.setGameStatus(GAME.STATUS.PLAYING);
		if (DEBUG.GAMESERVER)
			util.log("GAME CREATED: gid: " + data.gid + " " + data.player1 +
				" vs " + data.player2);
		return data;
	};

	this.endGame = function (gid) {
		if (DEBUG.GAMESERVER)
			util.log("GAMESERVER: ENDED GAME : " + gid);
		this.server.emitEndedGame({
			gid : gid
		});
		this.server.getScoreboard().pushScores();

		var p1Id = this.activeGames[gid].pids[0];
		var p2Id = this.activeGames[gid].pids[1];
		var client1, client2;
		client1 = this.server.getClientById(p1Id);
		client2 = this.server.getClientById(p2Id);

		if (client1 !== null)
			client1.setGameStatus(GAME.STATUS.IDLE);
		if (client2 !== null)
			client2.setGameStatus(GAME.STATUS.IDLE);

		delete this.activeGames[gid];
	};

	this.generateGameId = function () {
		var id = String(Math.random()).slice(2);
		if (this.activeGames[id] === undefined) {
			return id;
		} else {
			return this.generateGameId();
		}
	};

	this.handleGameInfo = function (data) {
		if (data.gid === undefined ||
				this.activeGames[data.gid] === undefined) {
			return;
		}
		// private chat is handled directly by gameserver
		// no need to invoke Game instance
		if (data.action === GAME.ACTION.PRIVATE_CHAT) {
			data.params.msg = sanitizer.escape(data.params.msg);
			var gid = data.gid;
			var pid1 = this.activeGames[gid].pids[0];
			var pid2 = this.activeGames[gid].pids[1];
			server.emitGameInfo(pid1, data);
			server.emitGameInfo(pid2, data);
		} else {
			this.activeGames[data.gid].call(data);
		}
	};

	this.emitGameInfo = function (data) {
		if (this.activeGames[data.gid] === undefined) {
			return;
		}
		if (DEBUG.GAMESERVER)
			util.log("GAMESERVER EMIT INFO: " + JSON.stringify(data));
		server.emitGameInfo(data.pid, data);
	};

	this.getActiveGames = function () {
		var list = [];
		var game, gameRecord;
		for (var i in this.activeGames) {
			game = this.activeGames[i];
			gameRecord = {
				gid : game.gid,
				player1 : game.players[game.pids[0]].getName(),
				player2 : game.players[game.pids[1]].getName()
			};
			list.push(gameRecord);
		}
		return list;
	};

	this.playerDisconnected = function (pid) {
		var game;
		for (var key in this.activeGames) {
			game = this.activeGames[key];
			if (game.pids[0] === pid || game.pids[1] === pid) {
				if (DEBUG.GAMESERVER)
					util.log("GAMESERVER: Player disconnected: " + pid);
				game.playerDisconnected(pid);
			}
		}
	};

});

/*
	One Game instance is created for every single game between two players.
	It handles all the game logic (main logic is in the call() function whic
	is called by the GameServer). It also changes game phases, validates
	players' gamefields and so on.
*/

var Game = (function (gid, gs, p1, p2) {

	"use strict";

	this.gid = gid;
	this.gameServer = gs;
	this.players = {};
	this.players[p1.getID()] = new Player(p1.getID(), p1.getName());
	this.players[p2.getID()] = new Player(p2.getID(), p2.getName());
	this.name = "PID: " + this.gid + " " + p1.getName() + " vs " + p2.getName();

	this.phase = GAME.PHASE.ALIGNMENT;
	this.pids = [p1.getID(), p2.getID()];
	this.activePlayer = null;
	this.passivePlayer = null;

	this.call = function (data) {

		var params = data.params;

		switch(data.action) {

			case GAME.ACTION.RESET_FIELD:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (this.players[data.pid].getReady()) {
					this.sendServerMessage(data.pid,
						"You already confirmed your ship placement.");
				} else {
					this.players[data.pid].getGameField().
						resetField();
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.RESET_FIELD,
						params : {}
					});
					this.sendServerMessage(data.pid,
						"Your ships are reset!");
				}
				break;

			case GAME.ACTION.CONFIRM_ALIGNMENT:
				if (this.phase !== GAME.PHASE.ALIGNMENT) return;

				if (!this.players[data.pid].getReady()) {

					var testTable = new TestTable (params);
					if (!testTable.isTableValid()) {
						this.playerCheated(data.pid);
					} else {
						this.populateGameField(data.pid, params);
					}

					this.players[data.pid].setReady(true);
					this.sendServerMessage(data.pid,
						"Your ships are placed! Please wait for your opponent.");
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.CONFIRM_ALIGNMENT,
						params : {}
					});
					var opponentID = data.pid === this.pids[0] ?
						this.pids[1] : this.pids[0];
					this.sendServerMessage(opponentID,
						this.players[opponentID].getName() + " has placed his/her ships.");

				} else {
					this.sendServerMessage(data.pid,
						"You ships are already positioned!");
				}

				if (this.areBothPlayersReady()) {
					this.loadBattlePhase();
				}
				break;

			case GAME.ACTION.FIREAT:

				if (this.phase !== GAME.PHASE.BATTLE) return;
				if (this.activePlayer !== data.pid) {
					this.sendServerMessage(data.pid,
						"It is not your turn, please wait ...");
					return;
				}

				var opponent = this.pids[0] === data.pid ? this.pids[1] : this.pids[0];
				var result = this.players[opponent].getGameField().
					fireAt(params.row, params.col);

				if (result === ERROR.INVALID_MOVE) {
					this.sendServerMessage(data.pid,
						"You already fired at that position. Please fire again at" +
						" different position.");
				}
				else {
					// notifying opponent about the shot
					this.sendEventResult({
						pid : opponent,
						action : GAME.ACTION.FIREAT,
						params : { result : result, row : params.row, col : params.col }
					});

					// notyfing active player
					this.sendEventResult({
						pid : data.pid,
						action : GAME.ACTION.FIREAT_RESPONSE,
						params : { result : result, row : params.row, col : params.col }
					});

					if (result === HIT.GAME_OVER) {
						var winner = this.players[data.pid].getName();

						this.endGame({
							msg: winner + " has won the battle!",
							winner : this.activePlayer,
							loser : this.passivePlayer
						});
					}

					else if (result === HIT.WATER) {
						this.flipActivePlayer();
					}

				}
				break;

		}

	};

	this.areBothPlayersReady = function () {
		return this.players[this.pids[0]].getReady() &&
			this.players[this.pids[1]].getReady();
	};

	this.loadBattlePhase = function () {
		this.phase = GAME.PHASE.BATTLE;
		util.log(this.name + "\nGAME STARTED!");
		this.activePlayer = Math.random() > 0.5 ? this.pids[0] : this.pids[1];
		this.passivePlayer = this.activePlayer === this.pids[0] ?
			this.pids[1] : this.pids[0];

		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.LOAD_BATTLE_PHASE,
			params : {}
		});

		this.sendServerMessage(this.pids[0], "Battle has started! Good luck!");
		this.sendServerMessage(this.pids[1], "Battle has started! Good luck!");

		this.sendServerMessage(this.activePlayer, "It's your turn. Fire at will!");
		this.sendServerMessage(this.passivePlayer, "It's your opponent's turn," +
			" please wait for your turn.");
	};

	this.flipActivePlayer = function () {
		this.activePlayer = this.activePlayer === this.pids[0] ?
			this.pids[1] : this.pids[0];
		this.sendServerMessage(this.activePlayer,
			"It's your turn, fire at will!");
		this.passivePlayer = this.activePlayer === this.pids[0] ?
			this.pids[1] : this.pids[0];
	};

	this.sendEventResult = function (data) {
		data.gid = this.gid;
		if (DEBUG.GAME)
			util.log("GAME EMIT INFO: " + JSON.stringify(data));
		this.gameServer.emitGameInfo(data);
	};

	this.sendServerMessage = function (pid, message) {
		this.sendEventResult({
			pid : pid,
			action : GAME.ACTION.PRIVATE_CHAT,
			params : { author : "Server", msg : message }
		});
	};

	this.init = function () {
		// notifying two players that their game has started
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.START,
			opponentName : this.players[this.pids[1]].getName()
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.START,
			opponentName : this.players[this.pids[0]].getName()
		});
		// telling players to reset their game fields
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.RESET_FIELD,
			params : {}
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.RESET_FIELD,
			params : {}
		});
	};

	this.endGame = function (data) {
		util.log(JSON.stringify(data));
		this.sendEventResult({
			pid : this.pids[0],
			action : GAME.ACTION.GAME_OVER,
			msg : data.msg
		});
		this.sendEventResult({
			pid : this.pids[1],
			action : GAME.ACTION.GAME_OVER,
			msg : data.msg
		});

		// Insert game into database.
		this.gameServer.server.getDB().getStmt("ADD_GAME").
			run(data.winner, data.loser);

		if (DEBUG.GAME)
			util.log("GAME: GAME ENDED : " + this.gid);
		this.gameServer.endGame(this.gid);
	};

	this.playerDisconnected = function (pid) {
		var data = {
			msg : "Your opponent has disconnected!<br />Thus' you're the victor!",
			winner : this.pids[0] == pid ? this.pids[1] : this.pids[0],
			loser : pid
		};
		if (DEBUG.GAME) {
			util.log("GAME: Player disconnected.");
			util.log(JSON.stringify(data));
		}
		this.endGame(data);
	};

	this.playerCheated = function (pid) {
		var data = {
			msg : "Player caught cheating! Game ended.",
			winner : this.pids[0] == pid ? this.pids[1] : this.pids[0],
			loser : pid
		};
		if (DEBUG.GAME) {
			util.log("GAME: Player caught cheating!");
			util.log(JSON.stringify(data));
		}
		this.endGame(data);
	};

	this.populateGameField = function (pid, ships) {
		var table = this.players[pid].getGameField();
		var i, ship;
		for (i = 0; i < ships.length; i++) {
			ship = ships[i];
			if (ship.dir === "horizontal")
				table.addHorizontalShip(ship.row, ship.col, ship.len);
			else
				table.addVerticalShip(ship.row, ship.col, ship.len);
		}
		if (DEBUG.GAME)
			util.log("GAME: Populated gamefield with valid data.");
	};

});

/*
	Class: Player()
	Represents player, holds necessary information and references
	about her: like history of moves, reference to field object,
	whether player is ready for battle (in alignment phase).
*/
var Player = (function (_id_, _name_) {

	"use strict";

	var pid = _id_;
	var name = _name_;
	var gameField;
	var movesHistory;
	var ready;

	gameField = new Field();
	movesHistory = [];
	ready = false;
	return {
		getMovesHistory: function () {
			return movesHistory;
		},

		isMoveUnique: function (row, col) {
			var index = $.inArray(row + 'x' + col, movesHistory);
			return (index === -1 ? true : false);
		},

		pushMove: function (row, col) {
			movesHistory.push(row + 'x' + col);
		},

		getGameField: function () {
			return gameField;
		},

		setReady: function (isReady) {
			ready = isReady;
		},

		getReady: function () {
			return ready;
		},

		getID : function () {
			return pid;
		},

		getName : function () {
			return name;
		}
	};
});

/*
	Class: Field()
	Represents the field of game and provides manipulation with it.
	Basically has 10x10 matrix that holds information about each cell.
	Also knows how many ships are left in the field (getShipsLeft() method).
*/
var Field = (function() {

	"use strict";

	var matrix;
	var shipsLeft;

	function initializeMatrix() {
		matrix = new Array(10);
		for (var i = 0; i < 10; i++) {
			matrix[i] = new Array(10);
			for (var j = 0; j < 10; j++)
			matrix[i][j] = 0;
		}
	}

	function addShip(row, col, row_len, col_len) {
		if ((row < 0) || (col < 0)) return;
		if ((row >= 10) || (col >= 10)) return;

		if ((row_len == 0) && (col_len == 0)) return;

		matrix[row][col] = 2;
		addShip(
			row_len != 0 ? row + 1 : row,
			col_len != 0 ? col + 1 : col,
			row_len != 0 ? row_len - 1 : 0,
			col_len != 0 ? col_len - 1 : 0);
	}

	initializeMatrix();
	shipsLeft = 0;

	return {

		resetField: function () {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++)
				matrix[i][j] = 0;
			}
			shipsLeft = 0;
		},
		getMatrix: function () {
			return matrix;
		},

		printMatrix: function () {
			for (var i = 0; i < 10; i++)
			util.debug(matrix[i]);
		},

		getShipsLeft: function () {
			return shipsLeft;
		},

		fireAt: function (row, col) {
			function countWholeParts(row, col, move_row, move_col) {
				if ((typeof move_row == 'undefined') &&
						(typeof move_col == 'undefined')) {
					var count;
					count = countWholeParts(row + 1, col, 1, 0);
					count += countWholeParts(row - 1, col, -1, 0);
					count += countWholeParts(row, col + 1, 0, 1);
					count += countWholeParts(row, col - 1, 0, -1);
					return count;
				}

				if ((row < 0) || (col < 0)) return 0;
				if ((row >= 10) || (col >= 10)) return 0;
				if (matrix[row][col] < 2) return 0;

				return (matrix[row][col] == 2 ? 1 : 0) +
					countWholeParts(row + move_row, col + move_col, move_row, move_col);
			}

			if (shipsLeft <= 0) return HIT.GAME_OVER;

			switch (matrix[row][col]) {
				case FIELD.WATER_NOT_SHOT:
					matrix[row][col] = FIELD.WATER_SHOT;
					return HIT.WATER;

				case FIELD.WATER_SHOT:
					return ERROR.INVALID_MOVE;

				case FIELD.SHIP_NOT_SHOT:
					matrix[row][col] = FIELD.SHIP_SHOT;
					if (countWholeParts(row, col) == 0) {
						shipsLeft--;
						if (shipsLeft <= 0) return HIT.GAME_OVER;
						return HIT.WHOLE_SHIP;
					}
					return HIT.SHIP;

				case FIELD.SHIP_SHOT:
					return ERROR.INVALID_MOVE;
			}

		},

		addVerticalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship vertically : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, length, 0);
			shipsLeft++;
		},

		addHorizontalShip: function (row, col, length) {
			if (DEBUG.GAME)
				util.debug("Game: Added ship horizontally : row: " + row +
					" col: " + col + " Length: " + length);
			addShip(row, col, 0, length);
			shipsLeft++;
		},

		deleteShip: function (row, col) {
			if (DEBUG.GAME)
				util.debug("Game: Deleted ship : " + row + " " + col);

			function recursiveDelete(row, col, move_row, move_col) {
				if ((row < 0) || (col < 0)) return;
				if ((row >= 10) || (col >= 10)) return;
				if (matrix[row][col] < 2) return;

				matrix[row][col] = 0;
				recursiveDelete(row + move_row, col + move_col, move_row, move_col);
			}

			if (matrix[row][col] < 2) return;

			matrix[row][col] = 0;
			recursiveDelete(row + 1, col, 1, 0);
			recursiveDelete(row - 1, col, -1, 0);
			recursiveDelete(row, col + 1, 0, 1);
			recursiveDelete(row, col - 1, 0, -1);
			shipsLeft--;
		}
	};
});

/*
	TestTable is used to check if player has a valid gametable.
*/
var TestTable = (function (_ships_) {

	this.table = [];
	this.ships = _ships_;
	this.isValid = null;

	this.addShip = function (row, col, length, direction) {

		if (direction === "horizontal") {
			if (col < 0 || col + length > 10 || row < 0 || row > 9)
				return false;
		} else {
			if (row < 0 || row + length > 10 || col < 0 || col > 9)
				return false;
		}

		var startRow = row - 1;
		var startCol = col - 1;
		var endRow;
		var endCol;

		if (direction === "horizontal") {
			endRow = row + 1;
			endCol = col + length;
		} else {
			endRow = row + length;
			endCol = col + 1;
		}

		if (startRow < 0)
			startRow = 0;
		if (startCol < 0)
			startCol = 0;
		if (endRow > 9)
			endRow = 9;
		if (endCol > 9)
			endCol = 9;

		for (var i = startRow; i <= endRow; i++) {
			for (var j = startCol; j <= endCol; j++) {
				if (this.table[i][j] !== 0)
					return false;
			}
		}

		for (i = 0; i < length; i++) {
			if (direction === "horizontal")
				this.table[row][col+i] = 1;
			else
				this.table[row+i][col] = 1;
		}

		return true;
	};

	this.isTableValid = function () {
		return this.isValid;
	};

	this.validateTable = function () {
		var i, j;
		for (i = 0; i < 10; i++) {
			this.table[i] = [];
			for (j = 0; j < 10; j++) {
				this.table[i][j] = 0;
			}
		}

		if (this.ships.length !== 10) {
			this.isValid = false;
			return;
		}

		var ship, result;
		for (i = 0; i < this.ships.length; i++) {
			ship = this.ships[i];
			result = this.addShip(ship.row, ship.col, ship.len, ship.dir);
			if (!result) {
				this.isValid = false;
				return;
			}
		}

		this.isValid = true;
	};

	this.validateTable();

});

var ERROR = {
	// Dummy (probably not used)
	NONE: 0,
	// The move isn't legal (invalid coordinates for example)
	INVALID_MOVE: 1,
	// Player has already fired on that cell
	REPEATED_MOVE: 2,
	// It's not player's turn to fire
	WRONG_TURN: 3,
	// It's not possible to do that in current game phase
	INVALID_PHASE: 4
};

// Represents result of firing
var HIT = {
	// Hit the water
	WATER: 10,
	// Hit tile of enemy ship
	SHIP: 11,
	// Hit tile of enemy ship that was also last part of it
	WHOLE_SHIP: 12,
	// Hit last tile of last ship - won
	GAME_OVER: 13
};

var FIELD = {
	WATER_NOT_SHOT : 0,
	WATER_SHOT : 1,
	SHIP_NOT_SHOT : 2,
	SHIP_SHOT : 3
};

module.exports = GameServer;
