/*

	pw_server.js

*/

var util = require("util");
var sanitizer = require("sanitizer");
require("./pw_client");
require("../../../client/js/events");
require("./pw_gameserver");
require("./pw_database");
require("./pw_scoreboard");

DEBUG = {
	SERVER : true,
	GAMESERVER : true,
	GAME : true,
	IO : 2,
	DATABASE : true
};

/*
	PW_Server
*/
var PW_Server = function () {

	"use strict";

	this.io = null;
	this.db = new Database("pw.db");
	this.scoreboard = new Scoreboard(this);
	this.scoreboardNS = null;
	this.clients = {};

	this.userConnectHandler = function (data, socket, sanitized) {
		if (typeof data === undefined)
			return;
		if ((sanitized === undefined) || (sanitized == false))
			data.name = sanitizer.escape(data.name);
			
		var self = this;
		this.db.getStmt("CHECK_PLAYER").get(data.name, function(err, row) {
				if (row === undefined) {
					self.db.getStmt("ADD_PLAYER").run(data.name, function(err, row) {
							// Also refresh scoreboard (new entry!)
							self.scoreboard.pushScores();
							
							self.userConnectHandler(data, socket, true);
						}
					);
				}
				else {
					if (self.getClientById(row.id) != null) {
						socket.emit(CLIENT.AUTH, {
							error : true, 
							errorMsg : "User already logged in!"
						});
						return;
					}
					
					data.id = row.id;

					data.socket = socket;
					var client = new PW_Client(data);
					self.clients[client.getID()] = client;
					client.setGameStatus(GAME.STATUS.IDLE);
					socket.set("clientID", client.getID());
					socket.emit(CLIENT.AUTH, { 
						id : client.getID(),
						name : client.getName(),
						error : false 
					});
					socket.broadcast.emit(SERVER.USER_CONNECTED, {
						name : client.getName(),
						id : client.getID()
					});
					self.userListHandler({}, socket);
					var activeGames = self.gameServer.getActiveGames();
					for (var i in activeGames) {
						self.emitStartedGame(activeGames[i]);
					}
				}
			}
		);
	};

	this.userDisconnectHandler = function (socket) {
		var server = this;
		var clientID;
		socket.get("clientID", function(err, id) {
			var client = server.clients[id];
			if (client === undefined) { return; }
			delete server.clients[id];
			socket.broadcast.emit(SERVER.USER_DISCONNECTED, {
				name : client.getName(),
				id : client.getID()
			});
			clientID = client.getID();
		});
		this.gameServer.playerDisconnected(clientID);
	};

	this.publicMessageHandler = function (data, socket) {
		if (typeof data === "undefined")
			return;
		data.msg = sanitizer.escape(data.msg);
		socket.broadcast.emit(CHAT.PUBLIC_MESSAGE, data);
	};

	/*
		Sends a list of all connected clients to the one who asked
		this list.
	*/
	this.userListHandler = function (data, socket) {

		var list = [];
		for (var c in this.clients) {
			var client = this.clients[c];
			list.push({
				name : client.getName(),
				id : client.getID(),
				status : client.getGameStatus()
			});
		}
		socket.emit(CHAT.USER_LIST, list);

	};

	this.createGameHandler = function (data, socket) {

		socket.broadcast.emit(GAME.CREATE, data);
		var self = this;
		socket.get("clientID", function(err, id) {
			var client = self.clients[id];
			if (client === undefined) { return; }
			client.setGameStatus(GAME.STATUS.WAITING);
		});

	};

	this.deleteGameHandler = function (data, socket) {
		socket.broadcast.emit(GAME.DELETE, data);
	};

	this.joinGameHandler = function (data, socket) {

		var creator = this.clients[data.opponentID];
		var creatorSocket = creator.getSocket();
		// notify that creator of the game is not looking for opponent any more
		this.deleteGameHandler({
			name : data.opponentName,
			id : data.opponentID
			}, creatorSocket);

		var self = this;
		socket.get("clientID", function(err, id) {
			var joiner = self.clients[id];
			var joinerSocket = socket;
			var data = self.gameServer.createGame(creator, joiner);
			// telling other clients about new game which started
			self.emitStartedGame(data);
		});
	};

	this.bindListeners = function (server) {

		var server = this;
		this.io.sockets.on("connection", function(socket) {

			socket.on(CLIENT.AUTH, function (data) {
				if (DEBUG.SERVER)
					util.log(CLIENT.AUTH + " " + JSON.stringify(data));
				server.userConnectHandler(data, socket);
			});

			socket.on(CHAT.PUBLIC_MESSAGE, function (data) {
				if (DEBUG.SERVER)
					util.log(CHAT.PUBLIC_MESSAGE + " " + JSON.stringify(data));
				server.publicMessageHandler(data, socket);
			});

			socket.on(CHAT.USER_LIST, function (data) {
				if (DEBUG.SERVER)
					util.log(CHAT.USER_LIST + " " + JSON.stringify(data));
				server.userListHandler(data, socket);
			});

			socket.on(GAME.CREATE, function (data) {
				if (DEBUG.SERVER)
					util.log(GAME.CREATE + " " + JSON.stringify(data));
				server.createGameHandler(data, socket);
			});

			socket.on(GAME.DELETE, function (data) {
				if (DEBUG.SERVER)
					util.log(GAME.DELETE + " " + JSON.stringify(data));
				server.deleteGameHandler(data, socket);
			});

			socket.on(GAME.JOIN_REQUEST, function (data) {
				if (DEBUG.SERVER)
					util.log(GAME.JOIN_REQUEST + " " + JSON.stringify(data));
				server.joinGameHandler(data, socket);
			});

			socket.on(GAME.INFO, function (data) {
				if (DEBUG.SERVER)
					util.log(GAME.INFO + " " + JSON.stringify(data));
				server.gameServer.handleGameInfo(data);
			});

			socket.on(SCOREBOARD.REQUEST, function () {
				if (DEBUG.SERVER)
					util.log(SCOREBOARD.REQUEST);
				server.scoreboard.pushScores(socket);
			});

			socket.on("disconnect", function () {
				if (DEBUG.SERVER)
					util.log("DISCONNECT");
				server.userDisconnectHandler(socket);
			});

		});
		
		// Scoreboard broadcast namespace
		this.scoreboardNS = this.io.of('/scoreboard');
		this.scoreboardNS.on('connection', function (socket) {
			// ...
		});
	};

	/*
		Emits game info to specific user, pid and data are provided
		by GameServer and Game.
	*/
	this.emitGameInfo = function (pid, data) {
		var player = this.clients[pid];
		if (player === undefined) {
			return;
		}
		var playerSocket = player.getSocket();
		playerSocket.emit(GAME.INFO, data);
	};

	/*
		Emits message, that two players have started new game.
		This message will be put to the active games table.
	*/
	this.emitStartedGame = function (data, socket) {
		if (socket === undefined)
			this.io.sockets.emit(GAME.STARTED_GAME, data);
		else
			socket.emit(GAME.STARTED_GAME, data);
	};

	/*
		Emits message, that a game has ended, all the clients
		will remove that game record from their active games table.
	*/
	this.emitEndedGame = function (data) {
		this.io.sockets.emit(GAME.ENDED_GAME, data);
	};

	/*
		Emits whole scoreboard to the client.
	*/
	this.emitScoreboard = function (data, socket) {
		if (socket === undefined)
			this.scoreboardNS.emit(SCOREBOARD.DATA, data);
		else
			socket.emit(SCOREBOARD.DATA, data);
	};

	/*
		Is used by GameServer who composes human-readable names
		for its games.
	*/
	this.getClientById = function (id) {
		var client = this.clients[id];
		if (client === undefined)
			return null;
		else
			return client;
	};

	this.setIO = function (io) {
		this.io = io;
	};

	this.getDB = function () {
		return this.db;
	};
	
	this.getScoreboard = function () {
		return this.scoreboard;
	};

	this.gameServer = new GameServer(this);

};

module.exports = new PW_Server();
